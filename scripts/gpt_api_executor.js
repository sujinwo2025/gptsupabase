#!/usr/bin/env node
/**
 * gpt_api_executor.js
 * 
 * Executes structured HTTP requests generated by GPT models.
 * Handles GET, POST, PUT, PATCH, DELETE, and multipart/form-data uploads.
 * 
 * Usage:
 *   node gpt_api_executor.js <json_request_file_or_stdin> [--token <bearer_token>] [--dev]
 * 
 * Example:
 *   echo '{"method":"GET","path":"/files","base_url":"http://localhost:3000/api/v1","headers":{}}' | node gpt_api_executor.js --token mytoken123
 */

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';
import https from 'https';
import http from 'http';
import { URL } from 'url';
import FormData from 'form-data';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const DEFAULT_TIMEOUT = 30000; // 30s timeout

class GPTAPIExecutor {
  constructor(options = {}) {
    this.token = options.token || process.env.BEARER_TOKEN || null;
    this.verbose = options.verbose || false;
    this.timeout = options.timeout || DEFAULT_TIMEOUT;
    this.baseDir = options.baseDir || process.cwd();
  }

  log(...args) {
    if (this.verbose) console.log('[GPT Executor]', ...args);
  }

  error(...args) {
    console.error('[GPT Executor ERROR]', ...args);
  }

  /**
   * Parse and validate the GPT-generated request JSON
   */
  parseRequest(requestJson) {
    try {
      const req = typeof requestJson === 'string' ? JSON.parse(requestJson) : requestJson;

      if (!req.method || !req.path || !req.base_url) {
        throw new Error('Missing required fields: method, path, base_url');
      }

      return req;
    } catch (err) {
      this.error('Failed to parse request:', err.message);
      throw err;
    }
  }

  /**
   * Build full URL from base_url and path
   */
  buildUrl(baseUrl, pathname, query) {
    const url = new URL(baseUrl);
    url.pathname = pathname;

    if (query && Object.keys(query).length > 0) {
      Object.entries(query).forEach(([key, value]) => {
        url.searchParams.append(key, value);
      });
    }

    return url;
  }

  /**
   * Inject Bearer token into headers if not already present
   */
  injectAuth(headers) {
    const hdrs = { ...headers };
    if (this.token && !hdrs['Authorization']) {
      hdrs['Authorization'] = `Bearer ${this.token}`;
    }
    return hdrs;
  }

  /**
   * Handle file attachment for multipart/form-data
   */
  async attachFile(fileSpec, baseDirForResolution) {
    if (!fileSpec) return null;

    const { fieldname, content, filename } = fileSpec;

    if (!fieldname || !filename) {
      throw new Error('File spec must include fieldname and filename');
    }

    // If content is "<ATTACH-FILE>" or starts with "<ATTACH-FILE:...", load from disk
    if (content === '<ATTACH-FILE>' || content.startsWith('<ATTACH-FILE:')) {
      let filePath;

      if (content.startsWith('<ATTACH-FILE:')) {
        filePath = content.replace('<ATTACH-FILE:', '').replace('>', '');
      } else {
        // Try to resolve filename relative to baseDirForResolution
        filePath = path.resolve(baseDirForResolution, filename);
      }

      // Check if file exists
      if (!fs.existsSync(filePath)) {
        throw new Error(`File not found: ${filePath}`);
      }

      this.log(`Attaching file: ${filePath}`);
      return {
        fieldname,
        filename,
        stream: fs.createReadStream(filePath),
      };
    }

    // If content is base64, decode and create buffer
    if (typeof content === 'string' && content.length > 0) {
      try {
        const buffer = Buffer.from(content, 'base64');
        this.log(`Attached file (base64): ${filename}`);
        return {
          fieldname,
          filename,
          buffer,
        };
      } catch (err) {
        this.error('Failed to decode base64 content:', err.message);
        throw err;
      }
    }

    throw new Error('File content must be base64 string or <ATTACH-FILE> placeholder');
  }

  /**
   * Execute the HTTP request
   */
  async execute(requestJson) {
    const req = this.parseRequest(requestJson);
    const { method, path: pathname, base_url, headers = {}, query = {}, body, file } = req;

    this.log(`Executing: ${method} ${pathname}`);

    const url = this.buildUrl(base_url, pathname, query);
    const hdrs = this.injectAuth(headers);

    // Prepare request options
    const protocol = url.protocol === 'https:' ? https : http;
    const options = {
      method,
      headers: hdrs,
      timeout: this.timeout,
    };

    return new Promise((resolve, reject) => {
      const makeRequest = (bodyOrForm) => {
        const request = protocol.request(url, options, (res) => {
          let data = '';

          res.on('data', (chunk) => {
            data += chunk;
          });

          res.on('end', () => {
            try {
              const parsed = data ? JSON.parse(data) : {};
              resolve({
                statusCode: res.statusCode,
                headers: res.headers,
                body: parsed,
                rawBody: data,
              });
            } catch (err) {
              // Not JSON, return as is
              resolve({
                statusCode: res.statusCode,
                headers: res.headers,
                body: null,
                rawBody: data,
              });
            }
          });
        });

        request.on('error', reject);
        request.on('timeout', () => {
          request.destroy();
          reject(new Error(`Request timeout after ${this.timeout}ms`));
        });

        if (bodyOrForm instanceof FormData) {
          bodyOrForm.pipe(request);
        } else if (bodyOrForm) {
          request.write(bodyOrForm);
          request.end();
        } else {
          request.end();
        }
      };

      // If multipart/form-data upload
      if (file && (method === 'POST' || method === 'PUT')) {
        this.attachFile(file, this.baseDir)
          .then((attachedFile) => {
            if (!attachedFile) {
              makeRequest(body ? JSON.stringify(body) : null);
              return;
            }

            const form = new FormData();

            if (attachedFile.stream) {
              form.append(attachedFile.fieldname, attachedFile.stream, attachedFile.filename);
            } else if (attachedFile.buffer) {
              form.append(attachedFile.fieldname, attachedFile.buffer, attachedFile.filename);
            }

            // Add any additional body fields to form (if needed)
            if (body && typeof body === 'object') {
              Object.entries(body).forEach(([key, value]) => {
                form.append(key, JSON.stringify(value));
              });
            }

            options.headers = { ...options.headers, ...form.getHeaders() };
            makeRequest(form);
          })
          .catch(reject);
      } else {
        // Regular JSON request
        const bodyStr = body ? JSON.stringify(body) : null;
        if (bodyStr) {
          options.headers['Content-Type'] = 'application/json';
          options.headers['Content-Length'] = Buffer.byteLength(bodyStr);
        }
        makeRequest(bodyStr);
      }
    });
  }

  /**
   * Format and pretty-print response
   */
  formatResponse(response) {
    const { statusCode, body, rawBody } = response;

    console.log(`\nâœ“ Request completed with status ${statusCode}\n`);
    console.log('Response Body:');
    console.log(JSON.stringify(body || rawBody, null, 2));
    console.log('');
  }
}

/**
 * Main CLI entry
 */
async function main() {
  const args = process.argv.slice(2);

  let inputSource = null;
  let token = null;
  let verbose = false;
  let dev = false;

  // Parse arguments
  for (let i = 0; i < args.length; i++) {
    if (args[i] === '--token' && args[i + 1]) {
      token = args[++i];
    } else if (args[i] === '--verbose' || args[i] === '-v') {
      verbose = true;
    } else if (args[i] === '--dev') {
      dev = true;
    } else if (!args[i].startsWith('--')) {
      inputSource = args[i];
    }
  }

  const executor = new GPTAPIExecutor({
    token: token || process.env.BEARER_TOKEN,
    verbose,
    baseDir: process.cwd(),
  });

  try {
    let requestJson;

    if (inputSource && fs.existsSync(inputSource)) {
      // Read from file
      requestJson = fs.readFileSync(inputSource, 'utf-8');
      executor.log(`Loaded request from file: ${inputSource}`);
    } else if (inputSource) {
      // Treat as JSON string
      requestJson = inputSource;
    } else {
      // Read from stdin
      executor.log('Waiting for JSON input from stdin...');
      requestJson = await readStdin();
    }

    const response = await executor.execute(requestJson);
    executor.formatResponse(response);

    if (response.statusCode >= 400) {
      process.exit(1);
    }
  } catch (err) {
    executor.error(err.message);
    process.exit(1);
  }
}

/**
 * Helper: read from stdin
 */
function readStdin() {
  return new Promise((resolve, reject) => {
    let data = '';

    if (process.stdin.isTTY) {
      reject(new Error('No input provided and stdin is a TTY. Provide JSON file or pipe JSON.'));
      return;
    }

    process.stdin.setEncoding('utf-8');

    process.stdin.on('data', (chunk) => {
      data += chunk;
    });

    process.stdin.on('end', () => {
      resolve(data);
    });

    process.stdin.on('error', reject);
  });
}

// Only run main if this is the main module
if (import.meta.url === `file://${process.argv[1]}`) {
  main().catch((err) => {
    console.error('Fatal error:', err);
    process.exit(1);
  });
}

export default GPTAPIExecutor;
